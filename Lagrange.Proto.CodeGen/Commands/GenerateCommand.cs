using Lagrange.Proto.CodeGen.Format;
using Lagrange.Proto.CodeGen.Utility;

namespace Lagrange.Proto.CodeGen.Commands;

public static class GenerateCommand
{
    public static async Task Invoke(string[]? path, string? folder, bool recursive)
    {
        if (path == null && folder == null)
        {
            Console.WriteLine("No path or folder specified.");
            return;
        }
        
        if (path != null)
        {
            foreach (string file in path)
            {
                if (File.Exists(file))
                {
                    await GenerateProtoFile(file);
                }
                else
                {
                    Console.WriteLine($"File not found: {file}");
                }
            }
        }
        
        if (folder != null)
        {
            if (Directory.Exists(folder))
            {
                var files = Directory.GetFiles(folder, "*.proto", recursive ? SearchOption.AllDirectories : SearchOption.TopDirectoryOnly);
                foreach (string file in files)
                {
                    await GenerateProtoFile(file);
                }
            }
            else
            {
                Console.WriteLine($"Folder not found: {folder}");
            }
        }
    }
    
    private static async Task GenerateProtoFile(string file)
    {
        Console.WriteLine($"Generating proto file for {file}...");
        string fileName = Path.GetFileNameWithoutExtension(file);
        
        string proto = await File.ReadAllTextAsync(file);
        var lexer = new ProtoLexer(proto);
        var tokens = lexer.Tokenize();
        var parser = new ProtoParser(tokens);
        var protoFile = parser.ParseProto();
        
        var source = new SourceWriter();
        source.WriteLine("""
                         // <auto-generated/>

                         #nullable enable annotations
                         #nullable disable warnings
                         
                         #pragma warning disable CS8618

                         using Lagrange.Proto;
                         """);
        source.WriteLine();
        
        source.WriteLine($"namespace {protoFile.Package.NormailizePackageToNamespace()}");
        source.WriteLine('{');
        source.Indentation++;

        for (int i = 0; i < protoFile.Messages.Count; i++)
        {
            var message = protoFile.Messages[i];
            Console.WriteLine($"Generating message {message.Name} for {fileName}...");
            source.WriteLine("[ProtoPackable]");
            source.WriteLine($"internal partial class {message.Name}");
            source.WriteLine('{');
            source.Indentation++;

            for (int j = 0; j < message.Fields.Count; j++)
            {
                EmitField(source, message.Fields[j]);
                if (j < message.Fields.Count - 1) source.WriteLine();
            }

            source.Indentation--;
            source.WriteLine('}');
            if (i < protoFile.Messages.Count - 1) source.WriteLine();
        }

        source.Indentation--;
        source.WriteLine('}');
        
        string outputFile = Path.ChangeExtension(file, ".cs");
        await File.WriteAllTextAsync(outputFile, source.ToSourceText());
    }

    private static void EmitField(SourceWriter writer, ProtoField field)
    {
        string attribute = GenerateAttribute(field);
        string type = GenerateType(field);
        string fieldName = field.Name.ToPascalCase();
        
        string statement = $"{attribute} public {type} {fieldName} {{ get; set; }}";
        writer.WriteLine(statement);
    }

    private static string GenerateAttribute(ProtoField field)
    {
        if (field.Type.StartsWith("map"))
        {
            string firstType = field.Type.Split('<')[1].Split(',')[0].Trim();
            string secondType = field.Type.Split(',')[1].Split('>')[0].Trim();
            
            string? keyNumberHandling = GenerateNumberHanding(firstType);
            string? valueNumberHandling = GenerateNumberHanding(secondType);
            
            string baseAttribute = keyNumberHandling != null ? $"[ProtoMember({field.Number}, NumberHandling = {keyNumberHandling})]" : $"[ProtoMember({field.Number})]";
            if (valueNumberHandling != null) baseAttribute += $"[ProtoValueMember(NumberHandling = {valueNumberHandling})]";
            
            return baseAttribute;
        }
        else
        {
            string? numberHandling = GenerateNumberHanding(field.Type);
            if (numberHandling != null) return $"[ProtoMember({field.Number}, NumberHandling = {numberHandling})]";
        }
        
        return $"[ProtoMember({field.Number})]";
    }

    private static string? GenerateNumberHanding(string type)
    {
        return type switch
        {
            "sint32" or "sint64" => "ProtoNumberHandling.Signed",
            "fixed32" => "ProtoNumberHandling.Fixed32",
            "fixed64" => "ProtoNumberHandling.Fixed64",
            "sfixed32" => "ProtoNumberHandling.Signed | ProtoNumberHandling.Fixed32",
            "sfixed64" => "ProtoNumberHandling.Signed | ProtoNumberHandling.Fixed64",
            _ => null
        };
    }

    private static string GenerateType(ProtoField field)
    {
        string? primitiveType = field.Type switch
        {
            "int32" or "sint32" or "fixed32" or "sfixed32" => "int",
            "int64" or "sint64" or "fixed64" or "sfixed64" => "long",
            "uint32" => "uint",
            "uint64" => "ulong",
            "bool" => "bool",
            "string" => "string",
            "bytes" => "byte[]",
            "double" => "double",
            "float" => "float",
            _ => null
        };

        if (primitiveType == null && field.Type.StartsWith("map"))
        {
            string firstType = field.Type.Split('<')[1].Split(',')[0].Trim();
            string secondType = field.Type.Split(',')[1].Split('>')[0].Trim();
            
            string firstTypeName = GenerateType(new ProtoField { Type = firstType });
            string secondTypeName = GenerateType(new ProtoField { Type = secondType });
            primitiveType = $"Dictionary<{firstTypeName}, {secondTypeName}>";
        }
        
        if (field.Label.StartsWith("repeated"))
        {
            primitiveType = $"List<{primitiveType ?? field.Type}>";
        }

        return primitiveType ?? field.Type;
    }
}