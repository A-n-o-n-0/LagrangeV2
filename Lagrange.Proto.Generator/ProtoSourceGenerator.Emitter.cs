using System.Reflection;
using Lagrange.Proto.Generator.Utility;
using Microsoft.CodeAnalysis;

namespace Lagrange.Proto.Generator;

public partial class ProtoSourceGenerator
{
    private partial class Emitter(Parser parser)
    {
        private const string ProtoNumberHandlingTypeRef = "global::Lagrange.Proto.Serialization.ProtoNumberHandling";
        private const string IProtoSerializableTypeRef = "global::Lagrange.Proto.IProtoSerializable<{0}>";

        private readonly AssemblyName _assemblyName = typeof(ProtoSourceGenerator).Assembly.GetName();

        private readonly string _fullQualifiedName = parser.Namespace == null
            ? $"global::{parser.TypeDeclarations[0].Split(' ').Last()}"
            : $"global::{parser.Namespace}.{parser.TypeDeclarations.Reverse<string>().Aggregate(string.Empty, (x, y) => $"{x}.{y.Split(' ').Last()}").TrimStart('.')}";
        
        public void Emit(SourceProductionContext context)
        {
            var source = CreateSourceWriter();
            
            EmitTypeInfo(source);
            source.WriteLine();
            EmitSerializeMethod(source);
            source.WriteLine();
            EmitMeasureMethod(source);
            
            CompleteSource(source);

            string text = source.ToSourceText().ToString();
            string filename = GetFileName();
            context.AddSource(filename, text);
        }

        private SourceWriter CreateSourceWriter()
        {
            var source = new SourceWriter();

            source.WriteLine("""
                             // <auto-generated/>

                             #nullable enable annotations
                             #nullable disable warnings
                             
                             using Lagrange.Proto.Primitives;
                             """);
            source.WriteLine();
            
            if (parser.Namespace != null)
            {
                source.WriteLine($"namespace {parser.Namespace}");
                source.WriteLine('{');
                source.Indentation++;
            }
            
            for (int i = parser.TypeDeclarations.Count - 1; i > 0; i--)
            {
                source.WriteLine(parser.TypeDeclarations[i]);
                source.WriteLine('{');
                source.Indentation++;
            }

            source.WriteLine($"""[global::System.CodeDom.Compiler.GeneratedCodeAttribute("{_assemblyName.Name}", "{_assemblyName.Version}")]""");
            source.WriteLine($"{parser.TypeDeclarations[0]} : {string.Format(IProtoSerializableTypeRef, _fullQualifiedName)}");
            source.WriteLine('{');
            source.Indentation++;
            
            return source;
        }
        
        private static void CompleteSource(SourceWriter source)
        {
            while (source.Indentation > 0)
            {
                source.Indentation--;
                source.WriteLine('}');
            }
        }
        
        private string GetFileName() => $"{parser.TypeDeclarations.Reverse<string>().Aggregate(string.Empty, (x, y) => $"{x}.{y.Split(' ').Last()}").TrimStart('.')}.g.cs";
        
        private static void EmitIfNotNullStatement(SourceWriter source, string variableName, Action<SourceWriter> emitAction)
        {
            source.WriteLine($"if ({variableName} != null)");
            source.WriteLine("{");
            source.Indentation++;
            emitAction(source);
            source.Indentation--;
            source.WriteLine("}");
        }
        
        private static void EmitIfNotDefaultStatement(SourceWriter source, string variableName, Action<SourceWriter> emitAction)
        {
            source.WriteLine($"if ({variableName} != default)");
            source.WriteLine("{");
            source.Indentation++;
            emitAction(source);
            source.Indentation--;
            source.WriteLine("}");
        }
    }
}