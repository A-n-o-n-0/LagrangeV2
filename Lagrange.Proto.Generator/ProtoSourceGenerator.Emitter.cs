using Microsoft.CodeAnalysis;
using SF = Microsoft.CodeAnalysis.CSharp.SyntaxFactory;
using SK = Microsoft.CodeAnalysis.CSharp.SyntaxKind;

namespace Lagrange.Proto.Generator;

public partial class ProtoSourceGenerator
{
    private partial class Emitter(Parser parser)
    {
        private const string WriterFullName = "global::Lagrange.Proto.Primitives.ProtoWriter";
        
        public void Emit(SourceProductionContext context)
        {
            var classDeclaration = SF.ClassDeclaration(parser.Identifier)
                .AddModifiers(SF.Token(SK.PartialKeyword))
                .AddAttributeLists(SF.AttributeList().AddAttributes(EmitGeneratedCodeAttribute()))
                .AddMembers(EmitSerializeHandlerMethod(), EmitMeasureHandlerMethod())
                .AddBaseListTypes(SF.SimpleBaseType(SF.ParseName($"global::Lagrange.Proto.IProtoSerializable<{parser.Identifier}>")));
            
            var namespaceDeclaration = SF.NamespaceDeclaration(SF.ParseName(parser.Namespace ?? string.Empty))
                .AddMembers(classDeclaration);

            var compilationUnit = SF.CompilationUnit()
                .AddMembers(namespaceDeclaration)
                .AddUsings(
                    SF.UsingDirective(SF.ParseName("System")),
                    SF.UsingDirective(SF.ParseName("System.Collections.Generic"))
                    )
                .WithLeadingTrivia(SF.TriviaList(
                    SF.Comment("// <auto-generated />"),
                    SF.Comment("#nullable enable annotations"),
                    SF.Comment("#nullable disable warnings")
                    )
                );
            
            string code = compilationUnit.NormalizeWhitespace().ToFullString();
            context.AddSource($"{parser.Identifier}.g.cs", code);
        }
    }
}