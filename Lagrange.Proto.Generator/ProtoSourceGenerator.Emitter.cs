using System.CodeDom.Compiler;
using Lagrange.Proto.Generator.Utility;
using Lagrange.Proto.Generator.Utility.Extension;
using Lagrange.Proto.Serialization;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using SF = Microsoft.CodeAnalysis.CSharp.SyntaxFactory;
using SK = Microsoft.CodeAnalysis.CSharp.SyntaxKind;

namespace Lagrange.Proto.Generator;

public partial class ProtoSourceGenerator
{
    private class Emitter(Parser parser)
    {
        private const string WriterFullName = "global::Lagrange.Proto.Primitives.ProtoWriter";
        
        public void Emit(SourceProductionContext context)
        {
            var classDeclaration = SF.ClassDeclaration(parser.Identifier)
                .AddModifiers(SF.Token(SK.PartialKeyword))
                .AddAttributeLists(SF.AttributeList().AddAttributes(EmitGeneratedCodeAttribute()))
                .AddMembers(EmitSerializeHandlerMethod(), EmitMeasureHandlerMethod())
                .AddBaseListTypes(SF.SimpleBaseType(SF.ParseName($"global::Lagrange.Proto.IProtoSerializer<{parser.Identifier}>")));
            
            var namespaceDeclaration = SF.NamespaceDeclaration(SF.ParseName(parser.Namespace ?? string.Empty))
                .AddMembers(classDeclaration);

            var compilationUnit = SF.CompilationUnit()
                .AddMembers(namespaceDeclaration)
                .AddUsings(
                    SF.UsingDirective(SF.ParseName("System")),
                    SF.UsingDirective(SF.ParseName("System.Collections.Generic"))
                    )
                .WithLeadingTrivia(SF.TriviaList(
                    SF.Comment("// <auto-generated />"),
                    SF.Comment("#nullable enable annotations"),
                    SF.Comment("#nullable disable warnings")
                    )
                );
            
            string code = compilationUnit.NormalizeWhitespace().ToFullString();
            context.AddSource($"{parser.Identifier}.g.cs", code);
        }

        #region SerializeHandler

        private MethodDeclarationSyntax EmitSerializeHandlerMethod()
        {
            var syntax = new List<StatementSyntax> { EmitNullableCheckStatement(true, "obj", SF.ReturnStatement()) };
            
            foreach (var t in parser.Fields)
            {
                TypeSyntax type;
                string name;
                switch (t.Value.Syntax)
                {
                    case FieldDeclarationSyntax fieldDeclaration:
                    {
                        type = fieldDeclaration.Declaration.Type;
                        name = fieldDeclaration.Declaration.Variables[0].Identifier.ToString();
                        break;
                    }
                    case PropertyDeclarationSyntax propertyDeclaration:
                    {
                        type = propertyDeclaration.Type;
                        name = propertyDeclaration.Identifier.ToString();
                        break;
                    }
                    default:
                    {
                        throw new Exception($"Unsupported member type: {t.Value.GetType()}");
                    }
                }

                var tag = EmitTagSerializeStatement(t.Key, t.Value.WireType);
                var field = EmitMemberStatement(t.Value.WireType, name, type, t.Value.IsSigned);

                var block = SF.Block(SF.List<StatementSyntax>([tag, ..field]));

                if (parser.Model.GetTypeSymbol(type).IsValueType && !type.IsNullableType())
                {
                    if (parser.IgnoreDefaultFields)
                    {
                        syntax.Add(EmitDefaultCheckStatement(false, $"obj.{name}", block, false));
                    }
                    else
                    {
                        syntax.Add(tag);
                        syntax.AddRange(field);
                        syntax[syntax.Count - 1] = syntax[syntax.Count - 1].WithTrailingTrivia(SF.Comment("\n"));
                    }
                }
                else
                {
                    syntax.Add(EmitNullableCheckStatement(false, $"obj.{name}", block, false));
                }
            }

            string classFullName = $"global::{parser.Namespace}.{parser.Identifier}?";
            var parameters = SF.ParameterList()
                .AddParameters(SF.Parameter(SF.Identifier("obj")).WithType(SF.ParseTypeName(classFullName)))
                .AddParameters(SF.Parameter(SF.Identifier("writer")).WithType(SF.ParseTypeName(WriterFullName)));

            return SF.MethodDeclaration(SF.PredefinedType(SF.Token(SK.VoidKeyword)), "SerializeHandler")
                .AddModifiers(SF.Token(SK.PublicKeyword), SF.Token(SK.StaticKeyword))
                .WithParameterList(parameters)
                .WithBody(SF.Block(SF.List(syntax)));
        }
        
        private StatementSyntax[] EmitMemberStatement(WireType wireType, string identifier, TypeSyntax type, bool isSigned)
        {
            var symbol = parser.Model.GetTypeSymbol(type);
            if (type.IsNullableType() && symbol.IsValueType) identifier += ".Value";

            return wireType switch
            {
                WireType.VarInt => [EmitVarIntSerializeStatement(identifier, isSigned)],
                WireType.Fixed32 => [EmitFixed32SerializeStatement(identifier, isSigned)],
                WireType.Fixed64 => [EmitFixed64SerializeStatement(identifier, isSigned)],
                WireType.LengthDelimited when type.IsStringType() => [EmitStringSerializeStatement(identifier)],
                WireType.LengthDelimited when type.IsByteArrayType() => [EmitBytesSerializeStatement(identifier)],
                WireType.LengthDelimited when symbol.IsUserDefinedType() => EmitProtoPackableSerializeStatement(type.ToString(), identifier),
                _ => throw new Exception($"Unsupported wire type: {wireType} for {identifier}")
            };
        }

        private static StatementSyntax EmitTagSerializeStatement(int field, WireType wireType)
        {
            int tag = (field << 3) | (byte)wireType;
            var encoded = ProtoHelper.EncodeVarInt(tag);
            string comment = $"// Field {field} | WireType {wireType} | Tag {tag} = {field} | {(byte)wireType} ({wireType}) << 3";

            var array = new ExpressionSyntax[encoded.Length];
            for (int i = 0; i < encoded.Length; i++) array[i] = SF.LiteralExpression(SK.NumericLiteralExpression, SF.Literal(encoded[i]));
            var init = SF.InitializerExpression(SK.ArrayInitializerExpression).AddExpressions(array);
            var bytes = SF.StackAllocArrayCreationExpression(SF.ArrayType(SF.ParseTypeName("byte[]"))).WithInitializer(init);
            
            var access = SF.MemberAccessExpression(SK.SimpleMemberAccessExpression, SF.IdentifierName("writer"), SF.IdentifierName("WriteRawBytes"));
            return SF.ExpressionStatement(SF.InvocationExpression(access).AddArgumentListArguments(SF.Argument(bytes)))
                .WithTrailingTrivia(SF.Comment(comment));
        }
        
        private static StatementSyntax EmitVarIntSerializeStatement(string name, bool isSigned)
        {
            ExpressionSyntax arg = SF.MemberAccessExpression(SK.SimpleMemberAccessExpression, SF.IdentifierName("obj"), SF.IdentifierName(name));
            var access = SF.MemberAccessExpression(SK.SimpleMemberAccessExpression, SF.IdentifierName("writer"), SF.IdentifierName("EncodeVarInt"));

            if (isSigned)
            {
                var zigZag = SF.MemberAccessExpression(SK.SimpleMemberAccessExpression, SF.IdentifierName("global::Lagrange.Proto.Utility.ProtoHelper"), SF.IdentifierName("ZigZagEncode"));
                arg = SF.InvocationExpression(zigZag).AddArgumentListArguments(SF.Argument(arg));
            }
            
            return SF.ExpressionStatement(SF.InvocationExpression(access).AddArgumentListArguments(SF.Argument(arg)));
        }
        
        private static StatementSyntax EmitFixed32SerializeStatement(string name, bool isSigned)
        {
            ExpressionSyntax arg = SF.MemberAccessExpression(SK.SimpleMemberAccessExpression, SF.IdentifierName("obj"), SF.IdentifierName(name));
            var access = SF.MemberAccessExpression(SK.SimpleMemberAccessExpression, SF.IdentifierName("writer"), SF.IdentifierName("EncodeFixed32"));
            
            if (isSigned)
            {
                var zigZag = SF.MemberAccessExpression(SK.SimpleMemberAccessExpression, SF.IdentifierName("global::Lagrange.Proto.Utility.ProtoHelper"), SF.IdentifierName("ZigZagEncode"));
                arg = SF.InvocationExpression(zigZag).AddArgumentListArguments(SF.Argument(arg));
            }
            
            return SF.ExpressionStatement(SF.InvocationExpression(access).AddArgumentListArguments(SF.Argument(arg)));
        }
        
        private static StatementSyntax EmitFixed64SerializeStatement(string name, bool isSigned)
        {
            ExpressionSyntax arg = SF.MemberAccessExpression(SK.SimpleMemberAccessExpression, SF.IdentifierName("obj"), SF.IdentifierName(name));
            var access = SF.MemberAccessExpression(SK.SimpleMemberAccessExpression, SF.IdentifierName("writer"), SF.IdentifierName("EncodeFixed64"));
            
            if (isSigned)
            {
                var zigZag = SF.MemberAccessExpression(SK.SimpleMemberAccessExpression, SF.IdentifierName("global::Lagrange.Proto.Utility.ProtoHelper"), SF.IdentifierName("ZigZagEncode"));
                arg = SF.InvocationExpression(zigZag).AddArgumentListArguments(SF.Argument(arg));
            }
            
            return SF.ExpressionStatement(SF.InvocationExpression(access).AddArgumentListArguments(SF.Argument(arg)));
        }
        
        private static StatementSyntax[] EmitProtoPackableSerializeStatement(string typeName, string name)
        {
            var measure = SF.MemberAccessExpression(SK.SimpleMemberAccessExpression, SF.IdentifierName(typeName), SF.IdentifierName($"MeasureHandler"));
            var invocation = SF.InvocationExpression(measure).AddArgumentListArguments(SF.Argument(SF.MemberAccessExpression(SK.SimpleMemberAccessExpression, SF.IdentifierName("obj"), SF.IdentifierName(name))));
            var access = SF.MemberAccessExpression(SK.SimpleMemberAccessExpression, SF.IdentifierName("writer"), SF.IdentifierName("EncodeVarInt"));
            var serialize = SF.MemberAccessExpression(SK.SimpleMemberAccessExpression, SF.IdentifierName(typeName), SF.IdentifierName("SerializeHandler"));
            return
            [
                SF.ExpressionStatement(SF.InvocationExpression(access).AddArgumentListArguments(SF.Argument(invocation))),
                SF.ExpressionStatement(SF.InvocationExpression(serialize).AddArgumentListArguments(SF.Argument(SF.MemberAccessExpression(SK.SimpleMemberAccessExpression, SF.IdentifierName("obj"), SF.IdentifierName(name))), SF.Argument(SF.IdentifierName("writer"))))
            ];
        }
        
        private static StatementSyntax EmitBytesSerializeStatement(string name)
        {
            var arg = SF.MemberAccessExpression(SK.SimpleMemberAccessExpression, SF.IdentifierName("obj"), SF.IdentifierName(name));
            var access = SF.MemberAccessExpression(SK.SimpleMemberAccessExpression, SF.IdentifierName("writer"), SF.IdentifierName("EncodeBytes"));
            return SF.ExpressionStatement(SF.InvocationExpression(access).AddArgumentListArguments(SF.Argument(arg)));
        }
        
        private static StatementSyntax EmitStringSerializeStatement(string name)
        {
            var arg = SF.MemberAccessExpression(SK.SimpleMemberAccessExpression, SF.IdentifierName("obj"), SF.IdentifierName(name));
            var access = SF.MemberAccessExpression(SK.SimpleMemberAccessExpression, SF.IdentifierName("writer"), SF.IdentifierName("EncodeString"));
            return SF.ExpressionStatement(SF.InvocationExpression(access).AddArgumentListArguments(SF.Argument(arg)));
        }
        
        private static StatementSyntax EmitNullableCheckStatement(bool equals, string identifier, StatementSyntax statement, bool isBlock = true) => 
            SF.IfStatement(SF.BinaryExpression(equals ? SK.EqualsExpression : SK.NotEqualsExpression, SF.IdentifierName(identifier), SF.LiteralExpression(SK.NullLiteralExpression)), isBlock ? SF.Block(statement) : statement);
        
        private static StatementSyntax EmitDefaultCheckStatement(bool equals, string identifier, StatementSyntax statement, bool isBlock = true) => 
            SF.IfStatement(SF.BinaryExpression(equals ? SK.EqualsExpression : SK.NotEqualsExpression, SF.IdentifierName(identifier), SF.LiteralExpression(SK.DefaultLiteralExpression)), isBlock ? SF.Block(statement) : statement);

        private static AttributeSyntax EmitGeneratedCodeAttribute()
        {
            return SF.Attribute(typeof(GeneratedCodeAttribute).GetFullName())
                .AddArgumentListArguments(
                    SF.AttributeArgument(SF.LiteralExpression(SK.StringLiteralExpression, SF.Literal("Lagrange.Proto.Generator"))),
                    SF.AttributeArgument(SF.LiteralExpression(SK.StringLiteralExpression, SF.Literal("1.0.0"))));
        }

        #endregion

        #region MeasureHandler

        private MethodDeclarationSyntax EmitMeasureHandlerMethod()
        {
            ExpressionSyntax syntax;
            if (parser.Fields.Count == 0)
            {
                syntax = SF.LiteralExpression(SK.NumericLiteralExpression, SF.Literal(0));
            }
            else
            {
                int constant = 0;
                var expressions = new List<ExpressionSyntax>();

                foreach (var kv in parser.Fields)
                {
                    TypeSyntax type;
                    string name;
                    switch (kv.Value.Syntax)
                    {
                        case FieldDeclarationSyntax fieldDeclaration:
                        {
                            type = fieldDeclaration.Declaration.Type;
                            name = fieldDeclaration.Declaration.Variables[0].Identifier.ToString();
                            break;
                        }
                        case PropertyDeclarationSyntax propertyDeclaration:
                        {
                            type = propertyDeclaration.Type;
                            name = propertyDeclaration.Identifier.ToString();
                            break;
                        }
                        default:
                        {
                            throw new Exception($"Unsupported member type: {kv.Value.GetType()}");
                        }
                    }
                    var symbol = parser.Model.GetTypeSymbol(type);
                    string identifier = symbol.IsValueType && type.IsNullableType() ? name + ".Value" : name;
                    
                    var expr = kv.Value.WireType switch        
                    {
                        WireType.VarInt => EmitVarIntLengthExpression(identifier),
                        WireType.Fixed32 => SF.LiteralExpression(SK.NumericLiteralExpression, SF.Literal(4)),
                        WireType.Fixed64 => SF.LiteralExpression(SK.NumericLiteralExpression, SF.Literal(8)),
                        WireType.LengthDelimited when type.IsStringType() => EmitStringLengthExpression(identifier),
                        WireType.LengthDelimited when type.IsByteArrayType() => EmitBytesLengthExpression(identifier),
                        WireType.LengthDelimited when symbol.IsUserDefinedType() => EmitProtoPackableLengthExpression(identifier),
                        _ => throw new Exception($"Unsupported wire type: {kv.Value.WireType} for {type.ToString()}")
                    };
                    
                    var tag = ProtoHelper.EncodeVarInt((kv.Key << 3) | (byte)kv.Value.WireType);
                    if (symbol.IsValueType && !type.IsNullableType())
                    {
                        if (parser.IgnoreDefaultFields)
                        {
                            var left = SF.LiteralExpression(SK.NumericLiteralExpression, SF.Literal(0));
                            var right = SF.BinaryExpression(SK.AddExpression, SF.LiteralExpression(SK.NumericLiteralExpression, SF.Literal(tag.Length)), expr);
                            expr = EmitDefaultCheckExpression(name, left, right);
                        }
                        else
                        {
                            constant += tag.Length;
                        }
                    }
                    else // null check with obj.{identifier}
                    {
                        var left = SF.LiteralExpression(SK.NumericLiteralExpression, SF.Literal(0));
                        var right = SF.BinaryExpression(SK.AddExpression, SF.LiteralExpression(SK.NumericLiteralExpression, SF.Literal(tag.Length)), expr);
                        expr = EmitNullableCheckExpression(name, left, right);
                    }
                    
                    expressions.Add(expr);
                }
                
                syntax = SF.LiteralExpression(SK.NumericLiteralExpression, SF.Literal(constant));
                syntax = expressions.Aggregate(syntax, (current, expr) => SF.BinaryExpression(SK.AddExpression, current, expr));
            }

            string classFullName = $"global::{parser.Namespace}.{parser.Identifier}";
            var parameters = SF.ParameterList()
                .AddParameters(SF.Parameter(SF.Identifier("obj")).WithType(SF.ParseTypeName(classFullName)));
            
            return SF.MethodDeclaration(SF.PredefinedType(SF.Token(SK.IntKeyword)), "MeasureHandler")
                .AddModifiers(SF.Token(SK.PublicKeyword), SF.Token(SK.StaticKeyword))
                .WithParameterList(parameters)
                .WithBody(SF.Block(SF.ReturnStatement(syntax)));
        }
        
        private static ExpressionSyntax EmitVarIntLengthExpression(string identifier)
        {
            var obj = SF.MemberAccessExpression(SK.SimpleMemberAccessExpression, SF.IdentifierName("obj"), SF.IdentifierName(identifier));
            var access = SF.MemberAccessExpression(SK.SimpleMemberAccessExpression, SF.IdentifierName("global::Lagrange.Proto.Utility.ProtoHelper"), SF.IdentifierName("GetVarIntLength"));
            return SF.InvocationExpression(access).AddArgumentListArguments(SF.Argument(obj));
        }

        private static ExpressionSyntax EmitStringLengthExpression(string identifier)
        {
            var obj = SF.MemberAccessExpression(SK.SimpleMemberAccessExpression, SF.IdentifierName("obj"), SF.IdentifierName(identifier));
            var access = SF.MemberAccessExpression(SK.SimpleMemberAccessExpression, SF.IdentifierName("global::Lagrange.Proto.Utility.ProtoHelper"), SF.IdentifierName("CountString"));
            return SF.InvocationExpression(access).AddArgumentListArguments(SF.Argument(obj));
        }
        
        private static ExpressionSyntax EmitBytesLengthExpression(string identifier)
        {
            var obj = SF.MemberAccessExpression(SK.SimpleMemberAccessExpression, SF.IdentifierName("obj"), SF.IdentifierName(identifier));
            var access = SF.MemberAccessExpression(SK.SimpleMemberAccessExpression, SF.IdentifierName("global::Lagrange.Proto.Utility.ProtoHelper"), SF.IdentifierName("CountBytes"));
            return SF.InvocationExpression(access).AddArgumentListArguments(SF.Argument(obj));
        }
        
        private static ExpressionSyntax EmitProtoPackableLengthExpression(string name)
        {
            var obj = SF.MemberAccessExpression(SK.SimpleMemberAccessExpression, SF.IdentifierName("obj"), SF.IdentifierName(name));
            var access = SF.MemberAccessExpression(SK.SimpleMemberAccessExpression, SF.IdentifierName("global::Lagrange.Proto.Utility.ProtoHelper"), SF.IdentifierName("CountProtoPackable"));
            return SF.InvocationExpression(access).AddArgumentListArguments(SF.Argument(obj));
        }
        
        /// <summary>
        /// (obj == null ? left : right)
        /// </summary>
        private static ExpressionSyntax EmitNullableCheckExpression(string identifier, ExpressionSyntax left, ExpressionSyntax right) => SF.ParenthesizedExpression(
                SF.ConditionalExpression(SF.BinaryExpression(SK.EqualsExpression, SF.MemberAccessExpression(SK.SimpleMemberAccessExpression, SF.IdentifierName("obj"), SF.IdentifierName(identifier)), SF.LiteralExpression(SK.NullLiteralExpression)), left, right)
            );
        
        private static ExpressionSyntax EmitDefaultCheckExpression(string identifier, ExpressionSyntax left, ExpressionSyntax right) => SF.ParenthesizedExpression(
            SF.ConditionalExpression(SF.BinaryExpression(SK.EqualsExpression, SF.MemberAccessExpression(SK.SimpleMemberAccessExpression, SF.IdentifierName("obj"), SF.IdentifierName(identifier)), SF.LiteralExpression(SK.DefaultLiteralExpression)), left, right)
        );
        #endregion
    }
}