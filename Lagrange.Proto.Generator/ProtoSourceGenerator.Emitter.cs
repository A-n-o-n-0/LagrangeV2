using System.CodeDom.Compiler;
using Lagrange.Proto.Generator.Utility;
using Lagrange.Proto.Generator.Utility.Extension;
using Lagrange.Proto.Serialization;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using SF = Microsoft.CodeAnalysis.CSharp.SyntaxFactory;
using SK = Microsoft.CodeAnalysis.CSharp.SyntaxKind;

namespace Lagrange.Proto.Generator;

public partial class ProtoSourceGenerator
{
    private class Emitter(Parser parser)
    {
        private const string WriterFullName = "global::Lagrange.Proto.Primitives.ProtoWriter";
        
        public void Emit(SourceProductionContext context)
        {
            var classDeclaration = SF.ClassDeclaration(parser.Identifier)
                .AddModifiers(SF.Token(SK.PartialKeyword))
                .AddAttributeLists(SF.AttributeList().AddAttributes(EmitGeneratedCodeAttribute()))
                .AddMembers(EmitSerializeHandlerMethod());
            
            var namespaceDeclaration = SF.FileScopedNamespaceDeclaration(SF.ParseName(parser.Namespace ?? string.Empty))
                .AddMembers(classDeclaration);

            var compilationUnit = SF.CompilationUnit()
                .AddMembers(namespaceDeclaration)
                .AddUsings(
                    SF.UsingDirective(SF.ParseName("System")),
                    SF.UsingDirective(SF.ParseName("System.Collections.Generic"))
                    )
                .WithLeadingTrivia(SF.TriviaList(
                    SF.Comment("// <auto-generated />"),
                    SF.Comment("#nullable enable annotations"),
                    SF.Comment("#nullable disable warnings")
                    )
                );
            
            string code = compilationUnit.NormalizeWhitespace().ToFullString();
            context.AddSource($"{parser.Identifier}.g.cs", code);
        }
        
        private MethodDeclarationSyntax EmitSerializeHandlerMethod()
        {
            string methodName = $"{parser.Identifier}SerializeHandler";
            string classFullName = $"global::{parser.Namespace}.{parser.Identifier}?";
            var parameters = SF.ParameterList()
                .AddParameters(SF.Parameter(SF.Identifier("obj")).WithType(SF.ParseTypeName(classFullName)))
                .AddParameters(SF.Parameter(SF.Identifier("writer")).WithType(SF.ParseTypeName(WriterFullName)));

            var syntax = new List<StatementSyntax> { EmitNullableCheckStatement(true, "obj", SF.ReturnStatement()) };
            
            foreach (var t in parser.Fields)
            {
                TypeSyntax type;
                string name;
                switch (t.Value.Syntax)
                {
                    case FieldDeclarationSyntax fieldDeclaration:
                    {
                        type = fieldDeclaration.Declaration.Type;
                        name = fieldDeclaration.Declaration.Variables[0].Identifier.ToString();
                        break;
                    }
                    case PropertyDeclarationSyntax propertyDeclaration:
                    {
                        type = propertyDeclaration.Type;
                        name = propertyDeclaration.Identifier.ToString();
                        break;
                    }
                    default:
                    {
                        throw new Exception($"Unsupported member type: {t.Value.GetType()}");
                    }
                }

                var tag = EmitTagSerializeStatement(t.Key, t.Value.WireType);
                var field = EmitMemberStatement(t.Value.WireType, name, type, t.Value.IsSigned);

                if (parser.Model.GetTypeSymbol(type).IsValueType && !type.IsNullableType())
                {
                    syntax.Add(tag);
                    syntax.Add(field.AddBlankLine());
                }
                else
                {
                    var block = SF.Block(SF.List<StatementSyntax>([tag, field]));
                    syntax.Add(EmitNullableCheckStatement(false, $"obj.{name}", block, false));
                }
            }

            return SF.MethodDeclaration(SF.PredefinedType(SF.Token(SK.VoidKeyword)), methodName)
                .AddModifiers(SF.Token(SK.PrivateKeyword), SF.Token(SK.StaticKeyword))
                .WithParameterList(parameters)
                .WithBody(SF.Block(SF.List(syntax)));
        }

        private StatementSyntax EmitMemberStatement(WireType wireType, string identifier, TypeSyntax type, bool isSigned)
        {
            bool isValueType = parser.Model.GetTypeSymbol(type).IsValueType;
            if (type.IsNullableType() && isValueType) identifier += ".Value";

            return wireType switch
            {
                WireType.VarInt => EmitVarIntSerializeStatement(identifier, isSigned),
                WireType.Fixed32 => EmitFixed32SerializeStatement(identifier, isSigned),
                WireType.Fixed64 => EmitFixed64SerializeStatement(identifier, isSigned),
                WireType.LengthDelimited when type.IsStringType() => EmitStringSerializeStatement(identifier),
                WireType.LengthDelimited when type.IsByteArrayType() => EmitBytesSerializeStatement(identifier),
                _ => throw new Exception($"Unsupported wire type: {wireType} for {identifier}")
            };
        }

        private static StatementSyntax EmitTagSerializeStatement(int field, WireType wireType)
        {
            int tag = (field << 3) | (byte)wireType;
            var encoded = ProtoHelper.EncodeVarInt(tag);
            string comment = $"// Field {field} | WireType {wireType} | Tag {tag} = {field} | {(byte)wireType} ({wireType}) << 3";

            var array = new ExpressionSyntax[encoded.Length];
            for (int i = 0; i < encoded.Length; i++) array[i] = SF.LiteralExpression(SK.NumericLiteralExpression, SF.Literal(encoded[i]));
            var init = SF.InitializerExpression(SK.ArrayInitializerExpression).AddExpressions(array);
            var bytes = SF.StackAllocArrayCreationExpression(SF.ArrayType(SF.ParseTypeName("byte[]"))).WithInitializer(init);
            
            var access = SF.MemberAccessExpression(SK.SimpleMemberAccessExpression, SF.IdentifierName("writer"), SF.IdentifierName("WriteRawBytes"));
            return SF.ExpressionStatement(SF.InvocationExpression(access).AddArgumentListArguments(SF.Argument(bytes)))
                .WithTrailingTrivia(SF.Comment(comment));
        }
        
        private static StatementSyntax EmitVarIntSerializeStatement(string name, bool isSigned)
        {
            ExpressionSyntax arg = SF.MemberAccessExpression(SK.SimpleMemberAccessExpression, SF.IdentifierName("obj"), SF.IdentifierName(name));
            var access = SF.MemberAccessExpression(SK.SimpleMemberAccessExpression, SF.IdentifierName("writer"), SF.IdentifierName("EncodeVarInt"));

            if (isSigned)
            {
                var zigZag = SF.MemberAccessExpression(SK.SimpleMemberAccessExpression, SF.IdentifierName("global::Lagrange.Proto.Utility.ProtoHelper"), SF.IdentifierName("ZigZagEncode"));
                arg = SF.InvocationExpression(zigZag).AddArgumentListArguments(SF.Argument(arg));
            }
            
            return SF.ExpressionStatement(SF.InvocationExpression(access).AddArgumentListArguments(SF.Argument(arg)));
        }
        
        private static StatementSyntax EmitFixed32SerializeStatement(string name, bool isSigned)
        {
            ExpressionSyntax arg = SF.MemberAccessExpression(SK.SimpleMemberAccessExpression, SF.IdentifierName("obj"), SF.IdentifierName(name));
            var access = SF.MemberAccessExpression(SK.SimpleMemberAccessExpression, SF.IdentifierName("writer"), SF.IdentifierName("EncodeFixed32"));
            
            if (isSigned)
            {
                var zigZag = SF.MemberAccessExpression(SK.SimpleMemberAccessExpression, SF.IdentifierName("global::Lagrange.Proto.Utility.ProtoHelper"), SF.IdentifierName("ZigZagEncode"));
                arg = SF.InvocationExpression(zigZag).AddArgumentListArguments(SF.Argument(arg));
            }
            
            return SF.ExpressionStatement(SF.InvocationExpression(access).AddArgumentListArguments(SF.Argument(arg)));
        }
        
        private static StatementSyntax EmitFixed64SerializeStatement(string name, bool isSigned)
        {
            ExpressionSyntax arg = SF.MemberAccessExpression(SK.SimpleMemberAccessExpression, SF.IdentifierName("obj"), SF.IdentifierName(name));
            var access = SF.MemberAccessExpression(SK.SimpleMemberAccessExpression, SF.IdentifierName("writer"), SF.IdentifierName("EncodeFixed64"));
            
            if (isSigned)
            {
                var zigZag = SF.MemberAccessExpression(SK.SimpleMemberAccessExpression, SF.IdentifierName("global::Lagrange.Proto.Utility.ProtoHelper"), SF.IdentifierName("ZigZagEncode"));
                arg = SF.InvocationExpression(zigZag).AddArgumentListArguments(SF.Argument(arg));
            }
            
            return SF.ExpressionStatement(SF.InvocationExpression(access).AddArgumentListArguments(SF.Argument(arg)));
        }
        
        private static StatementSyntax EmitBytesSerializeStatement(string name)
        {
            var arg = SF.MemberAccessExpression(SK.SimpleMemberAccessExpression, SF.IdentifierName("obj"), SF.IdentifierName(name));
            var access = SF.MemberAccessExpression(SK.SimpleMemberAccessExpression, SF.IdentifierName("writer"), SF.IdentifierName("EncodeBytes"));
            return SF.ExpressionStatement(SF.InvocationExpression(access).AddArgumentListArguments(SF.Argument(arg)));
        }
        
        private static StatementSyntax EmitStringSerializeStatement(string name)
        {
            var arg = SF.MemberAccessExpression(SK.SimpleMemberAccessExpression, SF.IdentifierName("obj"), SF.IdentifierName(name));
            var access = SF.MemberAccessExpression(SK.SimpleMemberAccessExpression, SF.IdentifierName("writer"), SF.IdentifierName("EncodeString"));
            return SF.ExpressionStatement(SF.InvocationExpression(access).AddArgumentListArguments(SF.Argument(arg)));
        }
        
        private static StatementSyntax EmitNullableCheckStatement(bool equals, string identifier, StatementSyntax statement, bool isBlock = true) => 
            SF.IfStatement(SF.BinaryExpression(equals ? SK.EqualsExpression : SK.NotEqualsExpression, SF.IdentifierName(identifier), SF.LiteralExpression(SK.NullLiteralExpression)), isBlock ? SF.Block(statement) : statement);

        private static AttributeSyntax EmitGeneratedCodeAttribute()
        {
            return SF.Attribute(typeof(GeneratedCodeAttribute).GetFullName())
                .AddArgumentListArguments(
                    SF.AttributeArgument(SF.LiteralExpression(SK.StringLiteralExpression, SF.Literal("Lagrange.Proto.Generator"))),
                    SF.AttributeArgument(SF.LiteralExpression(SK.StringLiteralExpression, SF.Literal("1.0.0"))));
        }
    }
}